# Practice SQLI CTF

## Краткое описание уязвимости
SQL Injection - уязвимость, которая позволяет злоумышленнику создавать запросы к SQL базам данных, не предусмотренные разработчиком.
Возникает она из-за неправильной обработки данных, которые впоследствие присутствуют в запросе к базе данных.
Данный сервис позволяет получить все штрафы пользователя по имени человека.

## Способы защиты от уязвимости
- Корректная обработка и экранирование входных данных.
- Настройка прав доступа к базе данных.
- Использование `prepared statements` и параметризированных запросов.

## Запуск приложения
Для запуска приложения нужно:
1. Склонировать репозиторий:
```bash
git clone https://github.com/MinaevMax/Practice_SQLI.git
cd Practice_SQLI
```
2. Запуск приложения через docker-compose:
```bash
docker-compose up --build
```
3. Приложение будет запущено по адресу: [http://localhost:8080](http://localhost:8080)

## Описание уязвимости конкретно в данном приложении
Сервис позволяет получить флаг, находящийся в поле secret у сотрудника(таблица `employees`), выписавшего наибольшую сумму штрафов.
Есть хэндлер, который возвращает из бд только поля id штрафа и имя на кого он выписан.
Для того, чтобы получить флаг, нужно передать вместо имени запрос, который фильтрует и возвращает поле secret у нужной записи.

Также для улучшения взаимодействия пользователя и базы данных имеются хэндлеры позволяющие добавлять штраф в базу, а также узнавать количество записей в таблицах.

## POC-эксплоит для получения флага
Для получения флага, необходимо получить запись из таблицы, недоступной для получения из хэндлера. Запись лежит в поле secret у сотрудника с наибольшей суммой штрафов.

Для начала стоит исследовать структуру базы данных. Начнем с поиска таблиц, возможных для использования. 
Во вкладке статистики данных базы данных проверяем количество записей. Потом попробуем добавить 2 штрафа с одинаковым id работника и заметим, что количество записей в штрафах увеличилось на 2, а сотрудников на 1. Можно сделать вывод, что есть минимум 2 таблицы: со штрафами и с сотрудниками.
Нам же необходимо получить поле из таблицы сотрудников, однако, хэндлер позволяющий получать данные исходя из полученных всего 1 и берет он данные из таблицы штрафов.
Получить желаемое можно воспользовавшись SQL командой `UNION`, которую нужно использовать в передаваемом тексте. Но для этого стоит узнать, сколько полей возвращает хэндлер из БД. Сделаем пробный запрос на поиск штрафов по имени. Видим, что получено 3 значения: int, string, int. Стоит ожидать что флаг является строкой, а значит, искомый флаг, должен быть получен именно из поля возвращающего имя. Теперь необходимо узнать названия таблиц с которыми предстоит работать. Например, подойдет следующий запрос в форму для поиска штрафов по имени:

```
' UNION SELECT 0, TABLE_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES WHERE ''='
```

Запрос покажет нам все таблицы, а также количество записей в них. Теперь нужно сопоставить данные полученные из хэндлера со статистикой и полученными при последнем запросе. Если таблиц с нужным количеством записей несколько, то можно добавить новую запись, чтобы узнать какая из таблиц увеличилась. Тем самым мы найдем названия нужных нам таблиц.

Теперь осталось просто отфильтровать нужную нам запись, которая лежит в поле secret у сотрудника выписавшего наибольшую сумму штрафов. Сделаем это так: 

```
' UNION SELECT 0, secret, 0 FROM billdb.employees WHERE id = (SELECT employee_id FROM billdb.bills GROUP BY employee_id ORDER BY SUM(value) DESC LIMIT 1) AND ''='
```

В результате запрос вернет поле secret для сотрудника с наибольшей суммой штрафов, что и есть флаг.
Хэндлер возвращает 3 параметра: id штрафа, name человека, value штрафа, обернутые в текстовую оболочку. 
При получении флага `id` и `value` будут 0, а поле `name` будет отображать флаг(Это следует из запроса в примере).

Выполнение запросов лучше и удобнее всего проводить через любой удобный для Вас браузер.